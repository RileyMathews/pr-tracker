// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package gen

import (
	"context"
	"database/sql"
)

const deletePrByRepositoryAndNumber = `-- name: DeletePrByRepositoryAndNumber :exec
DELETE FROM pull_requests
WHERE repository = ?
AND number= ?
`

type DeletePrByRepositoryAndNumberParams struct {
	Repository string `json:"repository"`
	Number     int64  `json:"number"`
}

func (q *Queries) DeletePrByRepositoryAndNumber(ctx context.Context, arg DeletePrByRepositoryAndNumberParams) error {
	_, err := q.db.ExecContext(ctx, deletePrByRepositoryAndNumber, arg.Repository, arg.Number)
	return err
}

const deleteTrackedRepository = `-- name: DeleteTrackedRepository :exec
DELETE FROM tracked_repositories
WHERE repository = ?
`

func (q *Queries) DeleteTrackedRepository(ctx context.Context, repository string) error {
	_, err := q.db.ExecContext(ctx, deleteTrackedRepository, repository)
	return err
}

const getAllPullRequests = `-- name: GetAllPullRequests :many
SELECT
  number,
  title,
  repository,
  author,
  draft,
  created_at_unix,
  updated_at_unix,
  ci_status,
  last_comment_unix,
  last_commit_unix,
  last_ci_status_update_unix,
  last_acknowledged_unix,
  requested_reviewers
FROM pull_requests
`

func (q *Queries) GetAllPullRequests(ctx context.Context) ([]PullRequest, error) {
	rows, err := q.db.QueryContext(ctx, getAllPullRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PullRequest
	for rows.Next() {
		var i PullRequest
		if err := rows.Scan(
			&i.Number,
			&i.Title,
			&i.Repository,
			&i.Author,
			&i.Draft,
			&i.CreatedAtUnix,
			&i.UpdatedAtUnix,
			&i.CiStatus,
			&i.LastCommentUnix,
			&i.LastCommitUnix,
			&i.LastCiStatusUpdateUnix,
			&i.LastAcknowledgedUnix,
			&i.RequestedReviewers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrsByRepository = `-- name: GetPrsByRepository :many
SELECT
  number,
  title,
  repository,
  author,
  draft,
  created_at_unix,
  updated_at_unix,
  ci_status,
  last_comment_unix,
  last_commit_unix,
  last_ci_status_update_unix,
  last_acknowledged_unix,
  requested_reviewers
FROM pull_requests
WHERE repository = ?
`

func (q *Queries) GetPrsByRepository(ctx context.Context, repository string) ([]PullRequest, error) {
	rows, err := q.db.QueryContext(ctx, getPrsByRepository, repository)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PullRequest
	for rows.Next() {
		var i PullRequest
		if err := rows.Scan(
			&i.Number,
			&i.Title,
			&i.Repository,
			&i.Author,
			&i.Draft,
			&i.CreatedAtUnix,
			&i.UpdatedAtUnix,
			&i.CiStatus,
			&i.LastCommentUnix,
			&i.LastCommitUnix,
			&i.LastCiStatusUpdateUnix,
			&i.LastAcknowledgedUnix,
			&i.RequestedReviewers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPullRequestByRepoAndNumber = `-- name: GetPullRequestByRepoAndNumber :one
SELECT
  number,
  title,
  repository,
  author,
  draft,
  created_at_unix,
  updated_at_unix,
  ci_status,
  last_comment_unix,
  last_commit_unix,
  last_ci_status_update_unix,
  last_acknowledged_unix,
  requested_reviewers
FROM pull_requests
WHERE repository = ?
AND number = ?
LIMIT 1
`

type GetPullRequestByRepoAndNumberParams struct {
	Repository string `json:"repository"`
	Number     int64  `json:"number"`
}

func (q *Queries) GetPullRequestByRepoAndNumber(ctx context.Context, arg GetPullRequestByRepoAndNumberParams) (PullRequest, error) {
	row := q.db.QueryRowContext(ctx, getPullRequestByRepoAndNumber, arg.Repository, arg.Number)
	var i PullRequest
	err := row.Scan(
		&i.Number,
		&i.Title,
		&i.Repository,
		&i.Author,
		&i.Draft,
		&i.CreatedAtUnix,
		&i.UpdatedAtUnix,
		&i.CiStatus,
		&i.LastCommentUnix,
		&i.LastCommitUnix,
		&i.LastCiStatusUpdateUnix,
		&i.LastAcknowledgedUnix,
		&i.RequestedReviewers,
	)
	return i, err
}

const getTrackedAuthors = `-- name: GetTrackedAuthors :many
SELECT author FROM tracked_authors
`

func (q *Queries) GetTrackedAuthors(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTrackedAuthors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var author string
		if err := rows.Scan(&author); err != nil {
			return nil, err
		}
		items = append(items, author)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrackedRepositories = `-- name: GetTrackedRepositories :many
SELECT repository FROM tracked_repositories
`

func (q *Queries) GetTrackedRepositories(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTrackedRepositories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var repository string
		if err := rows.Scan(&repository); err != nil {
			return nil, err
		}
		items = append(items, repository)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT id, username, access_token FROM users
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.ID, &i.Username, &i.AccessToken); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveTrackedAuthor = `-- name: SaveTrackedAuthor :exec
INSERT INTO tracked_authors (author) VALUES (?)
`

func (q *Queries) SaveTrackedAuthor(ctx context.Context, author string) error {
	_, err := q.db.ExecContext(ctx, saveTrackedAuthor, author)
	return err
}

const saveTrackedRepository = `-- name: SaveTrackedRepository :exec
INSERT INTO tracked_repositories (repository) VALUES (?)
`

func (q *Queries) SaveTrackedRepository(ctx context.Context, repository string) error {
	_, err := q.db.ExecContext(ctx, saveTrackedRepository, repository)
	return err
}

const saveUser = `-- name: SaveUser :exec
INSERT INTO users (username, access_token) VALUES (?, ?)
`

type SaveUserParams struct {
	Username    string `json:"username"`
	AccessToken string `json:"access_token"`
}

func (q *Queries) SaveUser(ctx context.Context, arg SaveUserParams) error {
	_, err := q.db.ExecContext(ctx, saveUser, arg.Username, arg.AccessToken)
	return err
}

const upsertPullRequest = `-- name: UpsertPullRequest :exec
INSERT INTO pull_requests (
  number,
  title,
  repository,
  author,
  draft,
  created_at_unix,
  updated_at_unix,
  ci_status,
  last_comment_unix,
  last_commit_unix,
  last_ci_status_update_unix,
  last_acknowledged_unix,
  requested_reviewers
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT(repository, number) DO UPDATE SET
  title = excluded.title,
  repository = excluded.repository,
  author = excluded.author,
  draft = excluded.draft,
  updated_at_unix = excluded.updated_at_unix,
  ci_status = excluded.ci_status,
  last_comment_unix = excluded.last_comment_unix,
  last_commit_unix = excluded.last_commit_unix,
  last_ci_status_update_unix = excluded.last_ci_status_update_unix,
  last_acknowledged_unix = excluded.last_acknowledged_unix,
  requested_reviewers = excluded.requested_reviewers
`

type UpsertPullRequestParams struct {
	Number                 int64         `json:"number"`
	Title                  string        `json:"title"`
	Repository             string        `json:"repository"`
	Author                 string        `json:"author"`
	Draft                  bool          `json:"draft"`
	CreatedAtUnix          int64         `json:"created_at_unix"`
	UpdatedAtUnix          int64         `json:"updated_at_unix"`
	CiStatus               int64         `json:"ci_status"`
	LastCommentUnix        int64         `json:"last_comment_unix"`
	LastCommitUnix         int64         `json:"last_commit_unix"`
	LastCiStatusUpdateUnix int64         `json:"last_ci_status_update_unix"`
	LastAcknowledgedUnix   sql.NullInt64 `json:"last_acknowledged_unix"`
	RequestedReviewers     string        `json:"requested_reviewers"`
}

func (q *Queries) UpsertPullRequest(ctx context.Context, arg UpsertPullRequestParams) error {
	_, err := q.db.ExecContext(ctx, upsertPullRequest,
		arg.Number,
		arg.Title,
		arg.Repository,
		arg.Author,
		arg.Draft,
		arg.CreatedAtUnix,
		arg.UpdatedAtUnix,
		arg.CiStatus,
		arg.LastCommentUnix,
		arg.LastCommitUnix,
		arg.LastCiStatusUpdateUnix,
		arg.LastAcknowledgedUnix,
		arg.RequestedReviewers,
	)
	return err
}
